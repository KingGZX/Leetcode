/*
Q91
一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：

'A' -> 1
'B' -> 2
...
'Z' -> 26
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：

"AAJF" ，将消息分组为 (1 1 10 6)
"KJF" ，将消息分组为 (11 10 6)
注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。

题目数据保证答案肯定是一个 32 位 的整数。


示例 1：

输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
示例 2：

输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
示例 3：

输入：s = "0"
输出：0
解释：没有字符映射到以 0 开头的数字。
含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
示例 4：

输入：s = "06"
输出：0
解释："06" 不能映射到 "F" ，因为字符串含有前导 0（"6" 和 "06" 在映射中并不等价）。
*/

#include <iostream>
#include <vector>
using namespace std;

class Solution {
public:
    /*
    DP思路及动态转移方程：
        用dp[i] 代表字符串s 包含到位置的i字符的解码总数 
        不难发现，每个位置的状态只和前一个位置相关，因为最大也就是"26"罢了
        但有一些特殊情况可能需要特殊处理
        下面的转移情况都需要注意能否结合的情况，比如当前遍历到'7 8 9'等要看一看前面那个是不是为1，否则无法结合
            比如如果遍历到的字符是'0'，那它只能和前面那一位结合，那么(能结合情况下)总数应该为 dp[i - 2]
            如果遍历到的字符比较大'7' '8' '9' ，那么先去看看能不能和前一位结合：
                不能结合的话，自己本身解码成一个字符即可，那么继承dp[i - 1]即可，相当于在前面这些所有组合中新增一个字符而已
                能结合的话:
                    比如和前一个数字字符结合解码成一个字符，那么会有dp[i - 2]种解法
                    但仍旧可以不去结合的嘛！仍旧当独行侠,自己本身解码成一个字符，这里又会有dp[i - 1]种解法
                因此能结合的情况下dp[i] = dp[i - 1] + dp[i - 2]
            遍历到剩余的字符情况下：
                不能结合是同理的。能结合的话其实也一样。
        
        这里面要注意编程的细节就是 dp[i - 2]，i - 1我们并不担心，因为for循环从i = 1开始永远不会越界。
        i - 2是说不定的，所以用到dp[i - 2]的地方全部改为   (i - 2 >= 0 ? dp[i - 2] : 1)
        取1是因为，自己把前面的数结合掉后没有另外的数字了，只解码出了一个字符

        击败：
        100%
        97%
    */
    int numDecodings(string s) {
        if(s[0] == '0') return 0;
        vector<int> dp(s.length(), 0);
        dp[0] = 1;
        for(int i = 1 ; i < s.length() ; i ++){
            if(s[i] == '0'){
                if(s[i - 1] == '0' || s[i - 1] >= '3')
                    return 0;
                // 否则只能和前面这个结合  如果这个0出现位置前面只有一个数，那么只能设置为1
                dp[i] = i - 2 >= 0 ? dp[i - 2] : 1;
            }
            else if(s[i] <= '6'){
                if(s[i - 1] == '0' || s[i - 1] >= '3')
                    dp[i] = dp[i - 1];
                else
                    dp[i] = dp[i - 1] + (i - 2 >= 0 ? dp[i - 2] : 1);
            }
            else{
                if(s[i - 1] >= '2' || s[i - 1] == '0')
                    dp[i] = dp[i - 1];
                else
                    dp[i] = dp[i - 1] + (i - 2 >= 0 ? dp[i - 2] : 1);
            }
        }
        return *(dp.end() - 1);
    }
};

int main(){
    Solution s;
    s.numDecodings("2101");
    return 0;
}