/*
 * @author: Zhexuan Gu
 * @Date: 2023-01-03 10:04:22
 * @LastEditTime: 2023-01-08 17:17:40
 * @FilePath: /CPPprojects/Leetcode/牛客Tencent11题/scrape_together_coins.cpp
 * @Description: Please implement
 */
#include <iostream>
#include <vector>
#include <map>
using namespace std;
#define ll long long

/*
描述
小Q十分富有，拥有非常多的硬币，小Q拥有的硬币是有规律的，对于所有的非负整数K，小Q恰好各有两个面值为2^K的硬币，
所以小Q拥有的硬币就是1,1,2,2,4,4,8,8,…。小Q有一天去商店购买东西需要支付n元钱，
小Q想知道有多少种方案从他拥有的硬币中选取一些拼凑起来恰好是n元（如果两种方案某个面值的硬币选取的个数不一样就考虑为不一样的方案）。



输入描述： 输入包括一个整数n(1≤n≤10^18)，表示小Q需要支付多少钱。注意n的范围。
输出描述： 输出一个整数，表示小Q可以拼凑出n元钱放的方案数。
示例1
输入： 6
输出： 3   (1 1 2 2) (1 1 4) (2 4)
*/

map<ll, int> dp;

int helper(ll n){
    if(dp.count(n)) return dp[n];
    int count;
    if(n % 2 == 0){
        count = helper(n >> 1) + helper((n - 2) >> 1);
    }
    else{
        count = helper(n >> 1);
    }
    dp[n] = count;
    return count;
}

int main(){
    ll n;           // 注意题目测试数据, 1e18 非常大,所以需要开 long long
    cin >> n;
    dp[1] = 1, dp[2] = 2, dp[3] = 1;
    // 不能像普通情况一样把所有值都给按顺序做出来,会超时,只能用递归的方法求解
    int ans = helper(n);
    cout << ans << endl;
    return 0;
}

/*
先举几个例子看看规律:

1:  只有 1 种方案 仅仅取一个1
2:  有 2 种方案   1、1   &&    2
3:  只有 1 种方案   1、2
4:  只有 2 种方案   1、1、2    &&   2、2
5:  有 2 种方案     1、4   &&   1、2、2
6:  在上面已经提及过  3  种 
7:  只有 1 种方案   1、4、2                     (0000 0111)

有如下思考：

对于奇数的组成方式, 我们唯一的组成方式就是 偶数 + 1
但问题是我们还得抛弃这个偶数中包含'1'的组成方式
相当于 我们 令  n - 1 仅仅计算由   2、2、4、4、8、8等数字构成的方式
用数学表达的话          n-1 = k1 * 2^1 + k2 * 2^2 + k3 * 2^3 + ... + kn * 2^n
那么实际上述表示等价于   (n - 1) >> 1 = k1 * 2^0 + k2 * 2^1 + ... + kn * 2^(n-1)
即用 1 1 2 2 4 4 ...... 组成(n - 1)/2  的方式

那么第一个对于[奇数]的转移方程就呼之欲出了：     f(n) = f((n - 1) >> 1) 实际上【(n - 1) >> 1】 == 【n >> 1】

对于偶数的组成方式,
仅存在两种可能,取两个1 和 不取1

{
对于不取1的情况
用上面数学表达的思想,其同样等价于  用 1 1 2 2 4 4 ...... 表达 n>>1
}

{
对于两个1都取的情况
可以简化成 n-2 用 2、2、4、4等组成的情况
即    (n - 2) >> 1 用 1 1 2 2 等等组成的情况

}
*/