/*
 * @author: Zhexuan Gu
 * @Date: 2023-01-05 12:38:02
 * @LastEditTime: 2023-01-05 16:49:50
 * @FilePath: /CPPprojects/Leetcode/牛客Tencent11题/convert_num_machine.cpp
 * @Description: Please implement
 */
#include <iostream>
#include <ostream>
#include <vector>
using namespace std;

/*
描述

小Q从牛博士那里获得了一个数字转换机，这台数字转换机必须同时输入两个正数a和b，并且这台数字转换机有一个红色的按钮和一个蓝色的按钮：
当按下了红色按钮，两个数字同时加1。
当按下了蓝色按钮，两个数字同时乘2。
小Q现在手中有四个整数a，b，A，B，他希望将输入的两个整数a和b变成A，B（a对应A，b对应B）。
因为牛博士允许小Q使用数字转换机的时间有限，所以小Q希望按动按钮的次数越少越好。请你帮帮小Q吧。

输入描述： 输入包括一行，一行中有四个正整数a，b，A，B，（1≤a，b，A，B≤10^9）。
输出描述： 如果小Q可以完成转换，输出最少需要按动按钮的次数，否则输出-1。
示例1
输入： 100 1000 202 2002
输出： 2
*/

int helper(int a, int b, int A, int B){
    if(a == A && b == B) return 0;
    else if(a == A && b != B) return -1;
    else if(b == B) return -1;
    else if(a > A || b > B) return -1;
    int ret;
    if((A & 1) == 0 && (B & 1) == 0) ret = helper(a, b, A >> 1, B >> 1);
    else ret = helper(a, b, A - 1, B - 1);
    if(ret == -1) return -1;
    return ret + 1;
}

int main(){
    int a, b, A, B;
    cin >> a >> b >> A >> B;
    int ans = helper(a, b, A, B);
    cout << ans << endl;
    return 0;
}

/*
----------------Copy 了一个大佬的思路----------------
看了几个高赞讨论，没有一个写在点子上的。最离谱的是，他们竟然都过了所有测试用例。我后来随便瞎写了一个半对不对的算法测试了一下，也过了全部用例。真是令人遗憾，牛客网的水平不行。 
先说单考虑a到A的算法： 
用二进制想，比如a=101，A=11101。 
最终一定是a目前的3个bits对准A最高位的3个bits。所以我们第一步要把101变成111，用2次加法按钮。 
接着按左移按钮一次，a=1110，A=11101。 
同理，最终一定是a目前的4个bits对准A最高位的4个bits。所以我们不需要做操作。 
接着按左移按钮一次，a=11100,A=11101。 
此时a和A具有相同位宽，只能用加法按钮操作，再按一次加法按钮，得到a==A。 
这个策略可以用反证法证明是最优的。比如假设存在下述策略最优：初始a=101，A=11101时，不做加法，先做左移。那么我们将来想让a次高位的0变成1，按加法按钮次数一定大于2。又由于对于给定a和A，按左移按钮的次数固定，为A的位宽减去a的位宽，故先位移的策略一定不是最优。 

所以贪心策略总结就是：假设a的位宽为m，先用加法让a与A的前m bits相等，再位移一位，此时m=m+1，循环。 

单单掌握贪心策略还不够，这个题最有意思的地方在于a*2=a+1当且仅当a=1。也就是说，a和b中有一个是1时，第一步按加法按钮和位移按钮是等价的。 
这也是为什么当输入为 
1 2 4 8时 
1*2=2，2*2=4； 
2*2=4，4*2=8； 
答案为2。 
当输入为 
1 2 4 6时 
1+1=2，2*2=4 
2+1=3，3*2=6 
答案也是2！ 
发帖人的代码没有一个能同时过这两个样例的，不信你们自己试一下。题目的judge里也少了1，2，4，6这种情况。 
所以当a和b有1时，要分两支去判断，有一支能达成，就可以达成。
*/