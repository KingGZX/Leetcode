/*
Q135
老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。
那么这样下来，老师至少需要准备多少颗糖果呢？

例:
    输入：[1,0,2]
    输出：5
    解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。

    输入：[1,2,2]
    输出：4
    解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。
    第三个孩子只得到 1 颗糖果，这已满足上述两个条件。
*/

#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>

using namespace std;

class Solution {
public:
    /*
    第一轮判断自身和右邻居的关系 -> 即如果右邻居比我大，我就更新右邻居 
    顺序遍历
    诚然，如果我比右邻居大的话我自己实际上是要更新的，但我自己不能随意更新，因为我的值是受我左边的序列影响的！
    第二轮判断自己和左邻居的关系 -> 即如果左邻居比我大，我就更新左邻居的值
    逆序遍历
    这样一来两次局部最优化后，我能保证糖果分配符合题设条件！
    */
    int candy(vector<int>& ratings) {
        int sz = ratings.size();
        vector<int> vec(sz, 1);
        // 先从左往右遍历，如果右边孩子得分高，就把右边孩子的糖果置为左边孩子的糖果数量+1
        // 经过这一轮操作确定自己的右邻居和自己的关系，确保比自己分高的右邻居拿到更多的糖果
        for(int i = 0 ; i < sz - 1 ; i ++){
            if(ratings[i + 1] > ratings[i]){
                vec[i + 1] = vec[i] + 1;
            }
        }
        /*
        // 如果如注释代码段一般判断和左邻居的关系也是用的顺序遍历 答案是错误的！ 
            // 例 1 3 2 1 第一轮后 vec是 1 2 1 1    如果用顺序遍历 最后结果是 1 2 2 1会发现vec[2]答案出问题
            // 因为我们没利用到上次的局部最优化结果！ 所以逆序遍历很重要，可以利用第一轮的结果
            // 类似n - 2  、  n   、 n - 1   、  n - 2 的序列 一轮 1 2 1 1  二轮后都会变为1 2 2 1 就出错了！
        for(int i = 0 ; i < sz ; i ++){
            if(i - 1 >= 0 && ratings[i - 1] > ratings[i] && vec[i - 1] <= vec[i]){
                vec[i - 1] = vec[i] + 1;
            }
        }
        */
        // 经过这轮操作，再次确定比自己表现好的左邻居拿到更多的糖果
        // 可以看见比上面多了一个条件，就是只有左边邻居表现比自己好且拿的糖果也不多于自己时才会进行更新
        // 例: 1 2 3 4 1  上一轮后  1 2 3 4 1   再次反过来遍历虽然ratings[3] > ratings[4]，但糖果也已经比他多了，无需更新
        // 又如 : 1 2 2 1 上一轮后  1 2 1 1      逆序遍历发现 raings[2] > ratings[3]但糖果数相同，所以更新！

        // 最后如: 1 2 87 87 87 2 1   一轮后  变为 1 2 3 1 1 1 1
        // 经过下面逆序遍历第一次后  因为 ratings[5] > ratings[6] && vec[5] == vec[6]  所以vec[5] = 2
        // 再一次循环！ 发现ratins[4] > ratins[5] 且 vec[4] < vec[5]了，这就是为什么这一轮逆序遍历增加了一个条件
        for(int i = sz - 1 ; i > 0 ; i --){
            if(ratings[i - 1] > ratings[i] && vec[i - 1] <= vec[i]){
                vec[i - 1] = vec[i] + 1;
            }
        }
        int ans = accumulate(vec.begin(), vec.end(), 0);
        return ans;
    }
};

int main(){
    Solution s;
    vector<int> can{1, 2, 87, 87, 87, 2, 1};
    s.candy(can);
    return 0;
}