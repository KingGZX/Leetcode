/*
给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。

我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 <= i <= n-2)，总满足 nums[i] <= nums[i + 1]。

示例 1:

输入: nums = [4,2,3]
输出: true
解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。
示例 2:

输入: nums = [4,2,1]
输出: false
解释: 你不能在只改变一个元素的情况下将其变为非递减数列。
*/

#include <iostream>
#include <vector>
using namespace std;

class Solution {
public:
    /*
    解题思路：
        假如一个数组中多次出现递减关系的，那么肯定是要多次改变的，显然是不行的。  例： 4 2 1出现了两次递减，已经不可解了
        假如递减关系出现在第一个位置   例1：4 2 3那么修改第一个就行是可解的。
        假如递减关系出现在倒数第二个位置， 例：4 5 6 7 8 2  那么修改最后一个元素即可，也是较为简单的。
        假如递减关系出现在除了这两个位置之外的其他地方(当然了，最后一个位置是不可能发生的，会越界的)：
            例     4 5 2 6 7 8这种情况我们发现没问题，修改2即可
            但又如此例     4 5 2 3 4 5 6   递减关系只出现了一次就是 5->2这儿，但2的左右两边并不符合非递减的关系，仍旧不可解
    */
    bool checkPossibility(vector<int>& nums) {
        int pos = -1;
        for(int i = 0 ; i < nums.size() - 1 ; i ++){
            if(nums[i] > nums[i + 1]){
                if(pos != -1){
                    return false;
                }
                pos = i;
            }
        }
        return pos == -1 || pos == 0 || pos == nums.size() - 2 || nums[pos - 1] <= nums[pos + 1] || nums[pos] <= nums[pos + 2];
    }
    // pos == -1就是说本身就是符合规则的
    // pos == 0 就是第一个数比第二个数大，修改第一个数即可
    // pos == size - 2，就是我们谈的在倒数第二个位置，此时也只需修改最后一个数即可
    // 其余位置情况需分类讨论：
    //     假如像   n - 4  n - 3   n    n - 1  ·····的类型的因为发生非递减关系的位置的前一个比后一个小，那么修改n本身即可
    //     又如     n - 3  n - 2   n    n - 3   n + 1 ····的类型，我们修改发生非递减关系的后一个的值也就是n - 3即可
    //     所以有了上述   nums[pos - 1] <= nums[pos + 1] || nums[pos] <= nums[pos + 2]
    //     而如果nums[pos] > nums[pos + 2]的话，我们其实必定就要修改两个值，就不行了，done！
};

int main(){

    return 0;
}